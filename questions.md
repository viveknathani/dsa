## Solve!

#arrays
1. Check whether n is present in a given array or not.
   (but don't really create an array)
2. Find the maximum and minimum element in an array.
   (and hence find the range too where range=max-min)
3. Reverse the array in the output.
4. Find the kth largest and kth smallest element in an array.
5. Find the number of occurences of a given number in an array.
6. Given an array that consists of only 0, 1, 2, sort the array without a sorting algorithm.
7. Move all negative elements to one side of the array.
8. Find union and intersection of two sorted arrays.
9. Cyclically rotate an array by one.
10. You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in the list. One of the integers is missing in the list. Write an efficient code to find the missing integer.
11. Find all pairs on an integer array whose sum is equal to the given number.
12. Find duplicates in an array.
13. Find common elements in three sorted arrays.
14. Find the first repeating element in an array of integers.
15. Find the first non-repeating element in an array of integers.
16. Given an array with all distinct elements, find the largest three elements.
17. Rearrange the array with alternating positive and negative terms with 0(1) extra space.
18. Find if there is any subarray with sum equal to zero.
19. Find largest sum contiguous subarray.
20. Find the factorial of a large number.
21. Find the maximum product subarray.
22. Find longest consecutive subsequence.
23. Given an array of size n and a number k, find all elements that appear more than n/k times.
24. GCD if given index ranges in an array.
25. Maximum profit by buying and selling a share at most twice.
26. Minimize the maximum difference between the heights.
27. Minimum number of jumps to reach end.
28. Find the two repetitive elements in a given array.
29. Find a triplet that sum to a given value.
31. Find the row with max number of 1's in a matrix.
32. Find the median in a row wise sorted matrix.
33. Print the matrix in a spiral manner.
34. Find whether an array is a subset of an array.
35. Implement two stacks in an array.

#strings

36. Check whether one string is rotation of another or not.
37. Remove duplicate characters from a string.
38. Check whether a string is a valid shuffle of two strings or not.
39. Find the longest palindrome in a string.
40. Find the longest recurring subsequence in a string.
41. Print all the permutations of the given string.
42. Split the binary string into two substrings with equal 0's and 1's.
43. Rearrange characters in a string such that no two adjacent are same.
44. Find the smallest window that contains all characters of the string itself.
45. Number of substrings with count of each character as "k".
46. Print the largest common subsequence between two strings.
47. Word wrap problem.
48. Generate all possible IP addresses from given string.
49. Edit distance.
50. Find the next greater number with same set of digits.
51. Prefix to infix, prefix to postfix, postfix to prefix, postfix to infix conversions.
52. Convert a sentence into its equivalent mobile numeric keypad sequence.
53. Balanced paranthesis problem.
54. Minimum number of swaps for bracket balancing.
55. Minimum number of bracket reversals needed to make an expression balanced.
56. Word break problem.
57. Minimum rotations required to get the same string.
58. Find the first repeated word in a string.
59. Efficiently find first repeated character in a string without using any additional data structure
one traversal.
60. Count all palindromic subsequence in a given string.
61. Number of flips to make binary string alternate.
62. Count number of given strings in a 2D character array.
63. Search a word in a 2D grid of characters.
64. Boyer Moore algorithm for pattern searching.
65. Reverse each word in a given string.
65. Anagram problem.

#linked list

66. Make following methods for a singly linked list and then for a doubly linked list.
    findLength(), search(element), delete(element), returnNthNode(n)
    countOccurence(n), maxAndMin()
67. SLL to CLL, DLL to CLL.
68. Get the 'nth' node from the end in a singly linked list.
69. Check whether a singly linked list is palindrome or not.
70. Reverse the linked list.
71. Reverse a linked list in a group of given size.
72. Detect loop and find its length in a linked list.
73. Delete the linked list.
74. Remove duplicates in a sorted linked list.
75. Remove duplicates in an unsorted linked list.
76. Move the last element to the front in a linked list.
77. Add '1' to a number represented as a linked list.
78. Add two numbers represented by linked lists.
79. Intersection of two sorted linked lists.
80. Intersection point of two linked lists.
81. Merge sort for linked lists.
82. Quicksort for linked lists.
83. Find middle element of a linked list.
84. Check if a linked list is CLL.
85. Split a circular linked list into two halves.
86. Deletion from CLL.
87. Count nodes in CLL.
88. Exchange first and last nodes in a linked list.
89. Reverse a dll.
90. Find pairs with a given sum in dll.
91. Count triplets in a sorted dll whose sum is equal to given value 'X'.
92. Sort a 'k' sorted dll.
93. Rotate dll by n nodes.
94. Rotate a dll in a group of given size.
95. Can we reverse a linked list in less than O(n)?
96. Why is Quicksort preferred for arrays and Mergesort for linked lists?

#stack

97. Implement stack.
98. Reverse a string using stack.
99. Check if the expression has valid or balanced parenthesis or not.
100. Implement stack using queues.
101. How to efficiently implement "k" stacks in an array?
102. Design a stack that supports getMin() in O(1) time and O(1) extra space.
103. Implement stack and queue using deque.
104. Prefix to infix, prefix to postfix, postfix to prefix, postfix to infix, infix to postfix
conversions using stack.
105. Find the next greater element.
106. The celebrity problem.
107. Arithmetic expression evaluation.
108. Evaluation of postfix expression.
109. Implement a method to insert an element at its bottom without using any other data structure.
110. Reverse a stack using recursion.
111. Sort a stack using recursion.
112. Merge overlapping intervals.
113. Largest rectangular area in a histogram.
114. Length of the longest valid substring.
115. Expression contains redundant bracket or not.
116. Find the maximum difference between nearest left and right smaller elements.
117. Remove brackets from an algebraic string containing + and - operators.
118. Implement a simple text editor using stack.
119. Minimum number of bracket reversals needed to make an expression balanced.

#queue

120. Implement queue using stack.
121. LRU Cache implementation.
122. Efficiently implement 'k' queues in an array.
123. Check if a queue can be sorted into another queue using a stack.
124. Level order tree reversal.
125. Reverse a queue using recursion.
126. Reverse the first 'k' elements of a queue.
127. Interleave the first half of the queue with second half.
128. Sorting a queue without extra space.
129. Find the first circular tour that visits all petrol pumps.
130. Minimum time required to rot all oranges.
131. Find maximum level sum in binary tree.
132. Distance of nearest cell having 1 in a binary matix.
133. First negative integer in every window of size 'k'.
134. Check if all levels of two trees are anagrams or not.
135. Sum of minimum and maximum elements of all subarrays of size 'k'.
136. Minimum sum of squares of character counts in a given string after removing 'k' characters.
137. Queue based approach or first non-repeating character in a stream.

#heap

138. Kth largest element in an array.
139. Kth smallest and largest element in an unsorted array.
140. Check if a binary tree is a heap.
141. Connect 'n' ropes with minimum cost.
142. Merge 'k' sorted arrays.
143. Largest dearrangement of a sequence.
144. Maximumd distinct elements after removing 'k' elements.
145. Median in a stream of running integers.
146. Largest triplet product in a stream.
147. Convert BST to min heap.
148. Merge 2 binary max heaps.
149. kth largest sum continuous subarrays.
150. Convert min heap to max heap.
151. Why is binary heap preferred over bst for priority queue?
152. Given level order traversal of a binary tree, check if the tree is a min heap.
153. Rearrange characters in a string so that no two adjacent are the same.
154. Minimum sum of two numbers formed from digits of an array.
155. Reoragnize strings (leetcode)
156. Merge 'k' sorted linked lists.
157. Smallest range in 'k' lists.

#tree

158. Make a tree with the given functions: Insertion of Node, Deletion of Node, InorderTraversal (Recursive and Iterative), Preorder Traversal (Recursive and Iterative), Postorder Traversal (Recursive and Iterative), Level Order Traversal, Reverse Level Order traversal, Searching of Value, Height of tree, Diameter of Tree, Mirror of Tree, Check tree is balanced or not, Find minimum value in tree, Find maximum value in tree
159. Make a bst with the given functions: Insertion into BST, Deletion from BST, Level order print, Traversal(inorder, preorder and postorder), Searching a value in BST, Check if is BST or not, Find inorder successor and inorder predecessor, Print all root node to leaf node pathsoFind min and max value in BST
160. Print top, bottom, left and right view of a binary tree.
161. Find nth node of inorder traversal.
162. Print level order traversal in spiral form.
163. Print diagonal traversal of a binary tree.
164. Print boundary traversal of a binary tree.
165. Construct a binary tree from given inorder and preorder traversal.
166. Construct a binary tree from inorder and level order traversal.
167. Construct a binary tree from string with bracket representation.
168. Convert a binary tree into dll.
169. Convert a binary tree to sum tree.
170. Find minimum swaps required to convert a binary tree to a bst.
171. Check if binary tree is sum tree or not.
172. Check if all leaf nodes are at same level or not.
173. Check if a binary tree contains duplicate subtrees of size 2 or more.
174. Check if two trees are mirror.
175. Check if given graph is tree or not.
176. Sum of nodes on the longest path from root to leaf node.
177. Find largest subtree sum in a tree.
178. Maximum sum of nodes in binary tree such that no two are adjacent.
179. Print all k-sum paths in a binary tree.
180. Find lowest common ancestor in a binary tree.
181. Find distance between two nodes in a binary tree.
182. Kth ancestor of a node in a binary tree.
183. Find all duplicate subtrees in a binary tree.
184. Tree isomorphism problem.
185. Construct bst from inorder and preorder traversal.
186. Construct bst from inorder and postorder traversal.
187. Construct bst from preorder traversal.
188. Convert binary tree to bst.
189. Convert normal bst to balanced bst.
190. Merge two bst.
191. Find lowest common ancestor of bst.
192. Find kth largest element in a bst.
193. Count pairs from two bsts whose sum is equal to given value 'x'.
194. Find the median of bst in O(n) time and O(1) space.
195. Count bst nodes that lie in the given range.
196. Replace every element with the least greater element on its right.
197. Given 'n' appointments, find the conflicting appointments.
198. Populate inorder successor of all nodes.
199. Check dead in a bst.
200. Check if preorder is valid or not.
201. Evaluate expression tree.
202. AVL tree: insertion and deletion.
203. RB tree: insertion and deletion.
204. B tree and B+ tree: go through text.

#graph

205. Make a graph class with the following methods:
(i) addNewEdge(source, destination, distance)
(ii) printAdjacencyList()
(iii) bfsTraversal()
(iv) dfsTraversal()
206. Detect cycle in a directed graph using bfs and dfs algorithm.
207. Detect cycle in an undirected graph using bfs and dfs algorithm.
208. Write the method to find the shortest path between two nodes using the bfs algorithm.
209. Write the method to find the shortest path between two nodes using the dijkstra algorithm.
210. Minimum steps to reach target by a knight.
211. Minimum number of jumps to reach end of given array.
212. Find the number of islands.
213. Find bridge ina graph.
214. Implement topological sorting algorithm.
215. Given a sorted dictionary of alien language, find the order of characters.
216. Flood fill algorithm.
217. Rat in a maze.
218. N-queen problem.
219. What is minimum spanning tree?
220. Implement kruskal's algorithm.
221. Implement prim's algorithm.
222. Total number of spanning tree in a graph.
223. Minimum product spanning tree.
224. Implement bellman ford algorithm.
225. Implement Floyd Warshall algorithm.
226. Travelling salesman problem.
227. Graph colouring problem.
228. Snake and ladders problem.
229. Count strongly connected algorithm. (kosaraju algo)
230. Check whether a graph is a bipartite or not.
231. Clone a graph.
232. Detect negative cycle in a graph.
233. Longest path in a directed acyclic graph.
234. Minimum cost to connect all cities.
235. Find if there is a path of more than 'k' length from a source.
236. M-colouring problem.
237. Hamiltonian cycle.
238. Permutations of numbers such that sum of 2 consecutive numbers is a perfect square.
239. Minimum edges to reverse to make path from a source to a destination.
240. Pathsto travel each nodes using each edge (Seven Bridges)
241. Kth heaviest adjacent node in a graph where each vertex has weight.
242. Ford-fulkerson algorithm for maximum flow problem.
243. Vertex cover problem.
244. Chinese postman or route inspection.
245. Number of triangles in a directed or undirected graph.
246. Minimise the cashflow among a given set of friends who have borrowed money from each other.
247. Two clique problem.

#set and map

248. Implement a class Map which has the following methods in O(1) time complexity.
249. Find the only repetitive number between 1 to n-1.
250. Difference between set, multiset, unordered_set, unordered_multiset.
251. Find the only element that appears 'b' times.
252. Remove duplicate or repeated words from string.
253. Find total number of distinct years from a string.
254. Equally divide into 2 sets such that one set has maximum distinct elements.
255. Check if a pair with a given product exists in a linked list.
256. Count of pairs between 2 arrays such that the sums are distinct.
257. Kth missing element in an unsorted array.
258. Number of strings that satisfy the given condition.
259. Number of ways to choose an integer such that there are exactly “k” elements greater than it in the given array.
260. Number of unique pairs in an array.
261. Given an array arr[] and an integer K. The task is to find the size of the maximum sub-set such that every
pair from the sub-set (X, Y) is of the form Y != (X * K) where X < Y.
262. Given N strings of equal lengths. The strings contain only digits (1 to 9). The task is to count the number of strings that have an index position such that the digit at this index position is greater than the digits at same index position of all the other strings.
263. Check if the array has an element which is equal to product of remaining elements.
264. Find if arrayhas an element whose value is half of array sum.

#search

265. Today, Monk went for a walk in a garden. There are many trees in the garden and each tree has an English alphabet on it. While Monk was walking, he noticed that all trees with vowels on it are not in good state. He decided to take care of them. So, he asked you to tell him the count of such trees in the garden.
Note : The following letters are vowels: 'A', 'E', 'I', 'O', 'U' ,'a','e','i','o' and 'u'.
266. There is a frog initially placed at the origin of the coordinate plane. In exactly 1 second, the frog can either move up 1 unit, move right 1 unit, or stay still. In other words, from position (x, y), the frog can spend 1 second to move to:
(x+1, y)
(x, y+1)
(x, y)
After T seconds, a villager who sees the frog reports that the frog lies on or inside a square of side-length  with coordinates (x,y), (x+s, y), (x,y+s), (x+s, y+s). Calculate how many points with integer coordinates on or inside this square could be the frog's position after exactly T seconds.
267. Given a List of N number a1,a2,a3........an, You have to find smallest number from the List that is repeated in the List exactly K number of times.
268. https://www.hackerearth.com/practice/algorithms/searching/binary-search/practiceproblems/algorithm/bishu-and-soldiers/
269. https://www.hackerearth.com/practice/algorithms/searching/binary-search/practiceproblems/algorithm/substring-in-blocks-335081c2/
270. https://www.hackerearth.com/practice/algorithms/searching/binary-search/practiceproblems/algorithm/friends-49/
 https://www.hackerearth.com/practice/algorithms/searching/binary-search/practiceproblems/algorithm/rasta-and-kheshtak/
271. https://www.hackerearth.com/practice/algorithms/searching/binary-search/practiceproblems/algorithm/kth-smallest-number-again-2/
272. [Aggressive Cows] (https://www.spoj.com/problems/AGGRCOW/)
273. [Book Allocation Problem] (https://www.geeksforgeeks.org/allocate-minimumnumber-pages/)
274. [EKO SPOJ] (https://www.spoj.com/problems/EKO/)
275. [Job Scheduling Algo] (https://www.geeksforgeeks.org/weighted-job-scheduling-logn-time/)
276. [Missing Number in AP] (https://www.geeksforgeeks.org/find-missing-numberarithmetic-progression/)
277. [Smallest number with atleast n trailing zeroes in factorial] (https://practice.geeksforgeeks.org/problems/smallest-factorial-number/0)
278. [Painters Partition Problem] (https://www.geeksforgeeks.org/painters-partitionproblem-set-2/)
279. [ROTI/PRATA SPOJ] (https://www.spoj.com/problems/PRATA/)
280. [Double Helix SPOJ] (https://www.spoj.com/problems/ANARC05B/)
281. [Subset Sums] (https://www.spoj.com/problems/SUBSUMS/)

#sort

282. [Bubble Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/practiceproblems/algorithm/save-patients/)
283. [Bubble Sort 2] (https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/practiceproblems/algorithm/benny-and-segments-marcheasy/)
284. [Insertion Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/practiceproblems/algorithm/monk-and-nice-strings-3/)
285. [Selection Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/practiceproblems/algorithm/old-keypad-in-a-foreign-land-24/)
286. [Merge Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/practiceproblems/algorithm/i-think-its-easy/)
287. [Merge Sort 2] (https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/practiceproblems/algorithm/shil-and-lucky-string-1/)
288. [Merge Sort 3] (https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/practiceproblems/algorithm/fredo-and-sums-1-605205cd/)
289. [Quick Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/practiceproblems/algorithm/one-sized-game/)
290. [Counting Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/practiceproblems/algorithm/finding-pairs-4/)
291. [Radix Sort 1] (https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/practiceproblems/algorithm/monk-and-sorting-algorithm/)
292. [Heap Sort] (https://www.hackerearth.com/practice/algorithms/sorting/heap-sort/practiceproblems/algorithm/divide-apples/)
